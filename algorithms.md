# Алгоритмы для поиска выпуклой оболочки множества точек на плоскости

---

## 1. Алгоритм Грэхема
**Описание**:  
Алгоритм начинается с выбора точки с минимальной $y$-координатой (если несколько точек имеют одинаковую $y$-координату, выбирается та, у которой $x$-координата минимальна). После этого все точки сортируются по углу наклона прямой, соединяющей их с этой точкой. Получив упорядоченные точки, алгоритм проходит по ним, добавляя каждую в стек, и удаляет точки из стека, если они нарушают выпуклость. Итерация продолжается до тех пор, пока не будет построен полный контур выпуклой оболочки.

**Особенности**:  
- Эффективен и прост в реализации.  
- Требует сортировки точек по углу, что определяет основную сложность алгоритма.

**Сложность**:  
$O(n \log n)$ из-за этапа сортировки.

---

## 2. Алгоритм Джарвиса ("алгоритм заворачивания подарка")
**Описание**:  
Алгоритм начинает с крайней левой точки, которая гарантированно принадлежит выпуклой оболочке. Затем последовательно выбирается следующая точка, образующая минимальный положительный угол с предыдущим ребром. Таким образом, алгоритм "обходит" оболочку, пока не вернётся к стартовой точке.

**Особенности**:  
- Подходит для небольших наборов данных.  
- Производительность зависит от числа точек на самой оболочке, а не от общего числа точек.  
- Прост в реализации, но менее эффективен для больших наборов точек.

**Сложность**:  
$O(nh)$, где $h$ — количество точек на выпуклой оболочке.

---

## 3. Алгоритм Чена
**Описание**:  
Алгоритм объединяет подходы Грэхема и Джарвиса. Точки делятся на небольшие группы, и для каждой группы строится выпуклая оболочка с использованием алгоритма Грэхема или Андрю. Затем происходит объединение всех полученных оболочек с использованием подхода Джарвиса. Алгоритм адаптирует размер групп таким образом, чтобы минимизировать общее время выполнения.

**Особенности**:  
- Очень эффективен для больших наборов точек.  
- Производительность зависит от числа точек на выпуклой оболочке.

**Сложность**:  
$O(n \log h)$, где $h$ — количество точек на выпуклой оболочке.

---

## 4. Алгоритм Эндрю
**Описание**:  
Точки сортируются по их $x$-координате. Затем оболочка строится в два этапа: сначала вычисляется верхняя часть оболочки, а затем — нижняя. В каждом этапе используются две точки, которые определяют текущее направление, и добавляется новая точка только если она не нарушает выпуклость.

**Особенности**:  
- Фактически это оптимизированная версия алгоритма Грэхема.  
- Реализуется легко и имеет хорошую производительность.

**Сложность**:  
$O(n \log n)$.

---

## 5. Перебор
**Описание**:  
Этот алгоритм проверяет для каждой пары точек, является ли отрезок между ними ребром выпуклой оболочки. Для этого все остальные точки проверяются на нахождение по одну сторону от прямой, заданной парой точек. Если условие выполняется, отрезок добавляется в оболочку.

**Особенности**:  
- Очень прост в реализации.  
- Подходит только для небольших наборов данных из-за крайне высокой вычислительной сложности.  

**Сложность**:  
$O(n^3)$.

---

## 6. QuickHull
**Описание**:  
Рекурсивный алгоритм, похожий на QuickSort. Сначала находятся две крайние точки, которые гарантированно принадлежат оболочке. Затем все остальные точки делятся на две группы относительно прямой, соединяющей эти точки. Для каждой группы рекурсивно находятся точки, наиболее удалённые от текущего отрезка, и процесс продолжается, пока не останется точек вне оболочки.

**Особенности**:  
- Работает быстро для случайно распределённых точек.  
- Производительность значительно ухудшается в худших случаях (например, когда все точки лежат на одной линии).

**Сложность**:  
Средняя: $O(n \log n)$, худшая: $O(n^2)$.

---

## 7. Алгоритм "разделяй и властвуй"
**Описание**:  
Точки делятся на две половины по $x$-координате. Для каждой половины строится выпуклая оболочка (например, с помощью алгоритма Андрю). Затем эти две оболочки объединяются в одну. Этап объединения требует линейного времени, так как точки уже отсортированы.

**Особенности**:  
- Очень эффективен для больших наборов данных.  
- Реализация сложнее, чем у других методов.

**Сложность**:  
$O(n \log n)$.

---

## 8. Алгоритм Монжо ("послойное удаление")
**Описание**:  
Итеративно ищет точки, образующие выпуклую оболочку, удаляя их из набора точек на каждом шаге. После удаления первого слоя оболочки процесс повторяется для оставшихся точек, пока они не закончатся.  

**Особенности**:  
- Подходит для визуализации "слоёв" выпуклости.  
- Неэффективен по времени, но прост для обучения и понимания.

**Сложность**:  
$O(n^2)$.

---

## 9. Инкрементальный алгоритм
**Описание**:  
Сначала берутся несколько точек (например, 3), которые гарантированно формируют оболочку. Затем оставшиеся точки добавляются по одной. После добавления новой точки оболочка пересчитывается, удаляя из неё точки, нарушающие выпуклость.

**Особенности**:  
- Итеративный подход делает его простым в реализации.  
- Может быть медленным на больших данных.

**Сложность**:  
$O(n^2)$.

---

## 10. Алгоритм Киркпатрика-Сайдела
**Описание**:  
Комбинация подхода "разделяй и властвуй" с инкрементальным методом. Основная идея — рекурсивное деление точек на вертикальные полосы, построение локальных оболочек для каждой полосы, а затем объединение их в глобальную оболочку. Это достигается за счёт поддержания активного списка точек, которые могут принадлежать оболочке.

**Особенности**:  
- Алгоритм оптимален по времени.  
- Реализация сложна из-за деталей объединения полос и обработки точек.

**Сложность**:  
$O(n \log n)$.

---
